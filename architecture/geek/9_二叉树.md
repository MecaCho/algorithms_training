二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值.

查找操作:
先取根节点，如果它等于我们要查找的数据，那就返回。
如果要查找的数据比根节点的值小，那就在左子树中递归查找。
如果要查找的数据比根节点的值大，那就在右子树递归查找.

插入操作：
如果要插入的数据比节点的数据大，并且节点的右子树为空，就将数据直接插到右子节点的位置。
如果不为空，就再递归遍历右子树，查找插入位置。
如果要插入的数据比节点数值小，并且节点的左子树为空，就将数据插入到左子节点的位置
如果不为空，就再递归遍历左子树，查找插入位置。

删除操作：
1）要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null, 比如图中的删除节点55.
2）要删除的节点只有一个子节点(只有左子节点或者右子节点),我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就好了。
3）要删除的节点有两个子节点，我们需要找到这个节点的右子树中的最小节点，把他替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点(如果没有左子结点，那就不是最小节点了).

二叉查找树可以支持快速地查找最大节点和最小节点，前驱节点和后继节点.
中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n),非常高效。

完全二叉树的高度小于等于log2n
平衡二叉查找树的高度接近logn.
插入，删除，查找的时间复杂度比较稳定，为O(logn).

散列表 vs 二叉查找树
1） 散列表是无序存储的，要有序的话，需要先排序， 二叉查找树，只需要中序遍历，就可以在O(n)时间复杂度内，输出有序的数据序列。

2) 散列表扩容耗时多，遇到散列冲突时，性能不稳定，常用的平衡二叉树性能稳定，时间复杂度稳定在O(logn)

3）一般来说，散列表查找，删除，插入操作的时间复杂度是常量级的。但因哈希冲突的存在，这个常量不一定比logn小，加上哈希函数的耗时，也就未必比平衡二叉查找树的效率高.

4) 散列表构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计，冲突接近方法，扩容，缩容等.
平衡二叉查找树只需要考虑平衡性这个问题。

5）为了避免过多的散列冲突，散列表装在因子不能太大，特别是基于开放寻址法接近冲突的散列表.

问题：
可以采用递归的办法max(depth(left), depth(right)) + 1.

我们在散列表那节中讲过，散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。
而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，
那我们为什么还要用二叉查找树呢？我认为有下面几个原因：
    第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。
        而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。
    第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，
        我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。
    第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，
        所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
    第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。
        平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。
    最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。
    综合这几点，平衡二叉查找树在某些方面还是优于散列表的，
    所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。