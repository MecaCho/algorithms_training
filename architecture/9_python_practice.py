# 由于全局解释锁（GIL）的原因，
# Python 的线程被限制到同一时刻只允许一个线程执行这样一个执行模型。
# 所以，Python 的线程更适用于处理I/O和其他需要并发执行的阻塞操作（比如等待I/O、等待从数据库获取数据等等），
# 而不是需要多处理器并行的计算密集型任务。


# 猴子补丁
# 在运行期间动态修改一个类或模块。

class A():
    def func(self):
        print("hello")

def monkey(self):
    print("monkey")


if __name__ == '__main__':
    A.func = monkey
    a = A()
    a.func()


# 类方法、静态方法、实例方法

'''
定义形式上：
a. 类方法和静态方法都是通过装饰器实现的，实例方法不是;

b. 实例方法需要传入self参数，类方法需要传入cls参数，而静态方法不需要传self或者cls参数。

2. 调用方式上：

实例方法只能通过实例对象调用；类方法和静态方法可以通过类对象或者实例对象调用，如果是使用实例对象调用的类方法或静态方法，最终都会转而通过类对象调用。

3. 应用场景：

a. 实例方法使用最多，可以直接处理实例对象的逻辑；类方法不需要创建实例对象，直接处理类对象的逻辑；静态方法将与类对象相关的某些逻辑抽离出来，不仅可以用于测试，还能便于代码后期维护。

b. 实例方法和类方法，能够改变实例对象或类对象的状态，而静态方法不能。

'''

