
# 缓存四大问题

# 1。缓存穿透

查询缓存---->没有---->数据库查询---->回写缓存    
查询不存在数据的现象我们称为缓存穿透。

## 解决办法

1。为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。设置过期时间。

2。在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -> 查 DB。
针对key异常多、请求重复率比较低的数据（攻击），我们就没有必要进行缓存，使用第二种方案直接过滤掉。
而对于空数据的key有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。

# 2。缓存击穿

在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，
就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。

## 影响

会造成某一时刻数据库请求量过大，压力剧增。

## 解决办法

多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁 来锁住它。
其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。
后面的线程进来发现已经有缓存了，就直接走缓存。

# 3。缓存雪崩

缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。

## 解决办法

1。事前：使用《集群缓存》，保证缓存服务的高可用    
2。事中：ehcache本地缓存 + Hystrix限流&降级,避免MySQL被打死    
3。事后：开启Redis持久化机制，尽快恢复缓存集群

# 4。缓存与数据库一致性问题----缓存与数据库不一致，怎么办？

## 数据库主从不一致

写后立刻读：
（1）主库一个写请求（主从没同步完成）    
（2）从库接着一个读请求，读到了旧数据    
（3）最后，主从同步完成

导致的结果是：主动同步完成之前，会读取到旧数据。    
可以看到，主从不一致的影响时间很短，在主从同步完成后，就会读到新数据。

## 缓存与数据库不一致

写后立刻读：    
旧数据放入缓存，即使主从同步完成，后续仍然会从缓存一直读取到旧数据。
可以看到，加入缓存后，导致的不一致影响时间会很长，并且最终也不会达到一致。

- 延时双删    
- 串行化

## 解决

在从库同步完成之后，如果有旧数据入缓存，应该及时把这个旧数据淘汰掉。


# 持久化策略

## 快照（RDB）

RDB持久化指的是在满足一定的触发条件时（在一个的时间间隔内执行修改命令达到一定的数量，或者手动执行SAVE和BGSAVE命令），对这个时间点的数据库所有键值对信息生成一个压缩文件dump.rdb，然后将旧的删除，进行替换。

默认开启
fork一个进程来进行持久化    
持久化的文件默认保存在dump.rdb, 可以修改redis.conf文件的dir配置路径
bgsave使用子进程持久化    
save使用主进程持久化    
shutdown时会自动触发

主从复制的情况下rdb关不掉

## AOF 日志

AOF持久化主要是Redis在修改相关的命令后，将命令添加到aof_buf缓存区的末尾，然后在每次事件循环结束时，根据appendfsync的配置（always是总是写入，everysec是每秒写入，no是根据操作系统来决定何时写入），判断是否需要将aof_buf写入AOF文件。

丢失的数据少，每1s执行一次保存，丢失数据不超过2s    
每秒可以写10W+数据    
可在配置中修改，appendonly 开关，使用everysec，不要用always    
appendonly.aof

aof重写：     
auto-aof-rewrite-min-size 64M
auto-aof-rewrite-percentage 100
bgrewriteaof

redis4。0    
混合持久化机制

# 各种集群

## 用的什么redis集群?Redis有哪些架构模式,它们有什么特别点?

1。cluster    
2。主从    
3。哨兵，小规模，中小型公司

演进：    
单机---------->  主从复制  --------->          哨兵模式         ---->  cluster  ---->    
            读写分离、容灾备份       解决单机故障，自动转移

- 单机版    
内存容量有限
处理能力有限
无法高可用

- 主从复制    

特点:

master/slave 角色
master/slave 数据相同
降低 master 读压力在转交从库

问题:

无法保证高可用
没有解决master写的压力

- 哨兵

特点:

保证高可用
监控各个节点
自动故障迁移

缺点:

主从模式,切换需要时间丢数据
没有解决master写的压力

- 集群(proxy型)

Twemproxy 是一个Twitter开源的一个redis和memcache 快速/轻量级代理服务器,Twemproxy是一个快速的单线程代理程序,支持 Memcached ASCII 协议和redis协议

特点:

多种hash算法: MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins
支持失败节点自动删除
后端Sharding 分片逻辑对业务透明,业务方的读写方式和操作单个Redis一致

缺点:

增加了新的proxy,需要维护其高可用    
failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预

- 集群(redis cluster)

从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。

特点:

无中心结构(不存在哪个节点影响性能瓶颈),少了proxy层    
数据按照slot存储分布在多个节点,节点间数据共享,可动态调整数据分布    
可扩展性,可线性扩展到1000个节点,节点可动态添加和删除    
高可用性,部分节点不可用时,集群仍可用,通过添加Slave做备份数据副本    
实现故障自动failover,节点之间通过gossip协议交换状态信息,用投票机制完成Slave到Master的角色提升

缺点:

资源隔离性较差,容易出现相互影响的情况
数据通过异步复制,不保证数据的强一致性




# Redis高可用分布式锁

setnx key不存在时设置key的值
setex 设置key值的同时设置过期时间

a: setnx k1 v1, setex (一定时间自动释放，防止进程挂了没有释放锁导致死锁) ，del k1   
b: setnx k1 v1


# 过期策略

## 定期删除

redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key、


# 使用缓存保护MySQL

MySQL 能承担的并发读写的量是有上限的，当系统的在线用户超过几万到几十万这个量级的时候，
单台 MySQL 就很难应付了。

# 为什么快？

Redis 是一个使用内存保存数据的高性能 KV 数据库，它的高性能主要来自于：
- 简单的数据结构；       
- 使用内存存储数据。     
- epoll      

缺点：    
Redis 仍然是一个不可靠的存储，它在设计上天然就不保证数据的可靠性，所以一般我们都使用 Redis 做缓存，很少使用它作为唯一的数据存储。

# 缓存穿透引起雪崩

如果我们的缓存命中率比较低，就会出现大量“缓存穿透”的情况。
缓存穿透指的是，在读数据的时候，没有命中缓存，请求“穿透”了缓存，直接访问后端数据库的情况。

1.少量的缓存穿透是正常的，我们需要预防的是，短时间内大量的请求无法命中缓存，请求穿透到数据库，导致数据库繁忙，
请求超时。    
大量的请求超时还会引发更多的重试请求，更多的重试请求让数据库更加繁忙，这样恶性循环导致系统雪崩。

2.当系统初始化的时候，比如说系统升级重启或者是缓存刚上线，这个时候缓存是空的，如果大量的请求直接打过来，很容易引发大量缓存穿透导致雪崩。

3.还有一种常见的缓存穿透引起雪崩的情况是，当发生缓存穿透时，如果从数据库中读取数据的时间比较长，也容易引起数据库雪崩。

4.我们缓存的数据是一个复杂的数据库联查结果，如果在数据库执行这个查询需要 10 秒钟，
    那当缓存中这条数据过期之后，最少 10 秒内，缓存中都不会有数据。
    如果这 10 秒内有大量的请求都需要读取这个缓存数据，这些请求都会穿透缓存，打到数据库上，
    这样很容易导致数据库繁忙，当请求量比较大的时候就会引起雪崩。
    
在系统初始化阶段，需要使用灰度发布或者其他方式来对缓存进行预热。

对于Cache aside和read/write through而带来的数据不一致问题，工作中是这样解决：
a写线程，b读线程：    
b线程：读缓存->未命中->上写锁>从db读数据到缓存->释放锁；
a线程：上写锁->写db->删除缓存/改缓存->释放锁；
这样来保证a，b线程并发读写缓存带来的脏数据问题；

# 缓存穿透：超大规模系统

并发请求的数量这个基数太大了，即使有很小比率的请求穿透缓存，打到数据库上请求的绝对数量仍然不小。加上大促期间的流量峰值，还是存在缓存穿透引发雪崩的风险。

对于像订单服务这类核心的业务，一个可行的方法是，我们启动一个更新订单缓存的服务，接收订单变更的 MQ 消息，然后更新 Redis 中缓存的订单数据

## 使用 Binlog 实时更新 Redis 缓存

有很多开源的项目就提供了订阅和解析 MySQL Binlog 的功能，
下面我们以比较常用的开源项目Canal为例，来演示一下如何实时接收 Binlog 更新 Redis 缓存。
Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，
MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。下图是 Canal 的工作原理：






