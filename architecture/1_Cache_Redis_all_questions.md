
# Redis的过期失效机制?

- 惰性清除。在访问key时，如果发现key已经过期，那么会将key删除。

- 定时清理。Redis配置项hz定义了serverCron任务的执行周期，默认每次清理时间为25ms，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么就继续对这个db进行清理，否则开始清理下一个db。

- 当执行写入命令时，如果发现内存不够，那么就会按照配置的淘汰策略清理内存，
淘汰策略主要由以下几种:    

eviction，不删除，达到内存限制时，执行写入命令时直接返回错误信息。

allkeys-lru，在所有key中，优先删除最少使用的key。（适合请求符合幂定律分布，也就是一些键访问频繁，一部分键访问较少）

allkeys-random，在所有key中，随机删除一部分key。（适合请求分布比较平均）

volatile-lru，在设置了expire的key中，优先删除最少使用的key。

volatile-random，在设置了expire的key中，随机删除一部分key。

volatile-ttl，在设置了expire的key中，优先删除剩余时间段的key。

4.0版本后增加以下两种：

volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰。

allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。

## LRU

可以使用HashMap+双向链表Node来实现，每次访问元素后，将元素移动到链表尾部，当元素满了时，将链表头部的元素移除。

## LFU   

如果一个数据在最近一段时间被访问的时次数越多，那么之后被访问的概率会越大，实现是每个数据 都有一个引用计数，每次数据被访问后，引用计数加1，需要淘汰数据时，淘汰引用计数最小的数据。

在Redis的实现中，每次key被访问后，引用计数是加一个介于0到1之间的数p，并且访问越频繁p值越大，而且在一定的时间间隔内， 如果key没有被访问，引用计数会减少

# Redis持久化方案rdb和aof的区别?

aof文件比rdb更新的频率高,优先使用aof还原数据

aof比rdb更安全也更大

rdb性能比aof好

如果两个都配了优先加载aof

AOF因为是保存了所有执行的修改命令，粒度更细，进行数据恢复时，恢复的数据更加完整，但是由于需要对所有命令执行一遍，效率比较低，同样因为是保存了所有的修改命令，同样的数据集，保存的文件会比RDB大，而且随着执行时间的增加，AOF文件可能会越来越大，所有会通过执行BGREWRITEAOF命令来重新生成AOF文件，减小文件大小。

Redis服务器故障重启后，默认恢复数据的方式首选是通过AOF文件恢复，其次是通过RDB文件恢复。

RDB是保存某一个时间点的所有键值对信息，所以恢复时可能会丢失一部分数据，但是恢复效率会比较高


# Redis的aof后台重写的触发条件?

- 可以由用户通过调用 BGREWRITEAOF手动触发    
- 服务器在AOF功能开启的情况下,会维持以下三个变量        
    记录当前AOF文件大小的变量aof_current_size
    记录最后一次AOF重写之后,AOF文件大小的变量 aof_rewrite_base_size
    增长百分比变量 aof_rewrite_perc
    
- 每次当 serverCron函数执行时,它都会检查以下条件是否全部满足,如果是的话,就会触发AOF重写    
    没有BGSAVE命令在进行
    没有BGREWRITEAOF在进行
    当前AOF文件大小大于server.aof_rewrite_min_size (默认值1MB)
    当前AOF文件大小和最后一次AOF重写后的大小之间的比率大于等于指定的增长百分比(默认百分比为100%)


# 简单介绍下什么是缓存击穿, 缓存穿透, 缓存雪崩? 能否介绍些应对办法?

# 解释下RESP?

Redis Serialization Protocol --- redis序列化协议

RESP是redis客户端和服务端之间使用的一种通讯协议, 特点: 实现简单,快速解析,可读性好

RESP可以用于序列化不同的数据类型,如:整型,字符串,数组..并且为错误提供专门的类型,客户端发送请求时,以字符串数组的作为待执行命令的参数,redis服务器根据不同的命令返回不同的类型

RESP是二进制安全协议,并且处理批量数据无序逐个请求处理,因此批量数据传输时,在请求参数中添加了数据长度作为前缀,传输层基于TCP协议,默认端口为6379

RESP支持五种数据类型:

简单字符串类型(Simple Strings),简单字符串以+开头

错误类型 (Errors),错误数据以-开头

整型(Integers),整数以:开头

批量字符串类型(Bulk Strings),批量字符串以$开头

数组类型(Arrays),数组以*开头

# 什么是哈希槽?    

从Redis3.0之后的版本支持redis-cluster集群,Redis-Cluster采用无中心结构,每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接

结构特点:

所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽
节点的fail是通过集群中超过半数的节点检测失效时才生效
客户端与redis节点直连,不需要中间proxy层,客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
redis-cluster把所有的物理节点映射到[0~16383]slot上(不一定平均分配),cluster负责维护node<->slot<->value
Redis集群预分好16384个桶,当需要在Redis集群中放置一个 key-value 时,根据 CRC16(key) mod 16384的值,决定将一个key放到哪个桶中

基本思想:

一共有16384个槽,每台服务器分管其中的一部分
插入一个数据的时候,先根据CRC16算法计算key对应的值,然后用该值对16384取余数,确定将数据放到哪个槽里面
在增加的时候,之前的节点个字分出一些槽给心节点,对应的数据也一起迁出
客户端可以向任何一个Redis节点发送请求,然后由节点将请求重定向到正确的节点上

为什么要选择的槽是16384个呢？ crc16会输出16bit的结果，可以看作是一个分布在0-2^16-1之间的数，redis的作者测试发现这个数对2^{14}求模的会将key在0-2^{14-1}之间分布得很均匀，因此选了这个值。


# Redis五大对象类型和其底层实现?

# 怎么保持Redis缓存里的数据与数据库里的一致?

不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。

举一个例子：

如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。
如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。

1.采用延时双删策略    
在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
    先删除缓存    
    再写数据库
    休眠500毫秒
    再次删除缓存

这种方案,还是有误差延时的,对于秒杀这种操作肯定是不行的! 另外,这种操作的流程是 先删除缓存,如果这时候有请求进来了

数据库还没更新操作,这时候如果量比较大可能会发生缓存穿透, 不过可能是单点穿透,这时候又对key写入了以前的值!

此时数据库更新了! 500毫秒后 再次删掉之前的key,重新穿透再缓存一次!

2.异步更新缓存(基于订阅binlog的同步机制)    

技术整体思路：(MySQL binlog增量订阅消费+消息队列+增量数据更新到redis)

读Redis：热数据基本都在Redis    
写MySQL: 增删改都是操作MySQL    
更新Redis数据：MySQ的数据操作binlog，来更新到Redis    
Redis更新

数据操作主要分为两大块：    
一个是全量(将全部数据一次写入到redis)
一个是增量（实时更新）(这里说的是增量,指的是mysql的update、insert、delate变更数据。)
读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。
这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。

这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。

当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!

# Redis的持久化是怎么实现的？

# 怎么防止AOF文件越来越大？

为了防止AOF文件越来越大，可以通过执行BGREWRITEAOF命令，会fork子进程出来，读取当前数据库的键值对信息，生成所需的写命令，写入新的AOF文件。

# Redis持久化策略该如何进行选择？

1.不需要考虑数据丢失的情况，那么不需要考虑持久化。

2.单机实例情况下，可以接受丢失十几分钟及更长时间的数据，可以选择RDB持久化，对性能影响小;
    如果只能接受秒级的数据丢失，只能选择AOF持久化。    
    
3.从服务器进行数据热备份的情况下，是否还需要持久化呢?
    主服务器不开启持久化，使得主服务器性能更好
    从服务器开启AOF持久化，关闭RDB持久化，并且定时对AOF文件进行备份，以及在凌晨执行bgaofrewrite命令来进行AOF文件重写，减小AOF文件大小

# AOF文件追加阻塞是什么？

修改命令添加到aof_buf之后，如果配置是everysec那么会每秒执行fsync操作，调用write写入磁盘一次，但是如果硬盘负载过高，fsync操作可能会超过1s，Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快，所以Redis的处理逻辑是会对比上次fsync成功的时间，如果超过2s，则主线程阻塞直到fsync同步完成，所以最多可能丢失2s的数据，而不是1s。

# Redis为什么是单线程的？

Redis采用单线程的优势:

- Redis项目的代码会更加清晰，处理逻辑会更加简单。

- 不用考虑多个线程修改数据的情况，修改数据时不用加锁，解锁，也不会出现死锁的问题，导致性能消耗。

- 不存在多进程或者多线程导致的切换而造成的一些性能消耗。

Redis采用单线程的劣势:

1.无法充分发挥多核机器的优势，不过可以通过在机器上启动多个Redis实例来利用资源。

# Redis性能为什么高?

Redis单机可以到到10W的QPS(每秒处理请求数)

1.全基于内存，数据全部存储在内存中，读取时没有磁盘IO，所以速度非常快。

2.Redis采用单线程的模型，没有上下文切换的开销，也没有竞态条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

3.Redis项目中使用的数据结构都是专门设计的

4.采用多路复用IO模型，可以同时监测多个流的IO事件能力，在空闲时，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态唤醒，轮询那些真正发出了事件的流，并只依次顺序的处理就绪的流

# Redis主从同步是怎么实现的？

主从节点建立连接后，从节点会进行判断

如果这是从节点之前没有同步过数据，属于初次复制，会进行全量重同步 那么从节点会向主节点发送PSYNC?-1 命令，请求主节点进行全量重同步。

如果这是从节点不说初次复制（例如出现掉线后重连），

这个时候从节点会将之前进行同步的Replication ID(一个随机字符串，标识主节点上的特定数据集)和offset（从服务器当前的复制偏移量）通过PSYNC 命令发送给主节点，主节点会进行判断，

如果Replication ID跟当前的Replication ID不一致，或者是当前buffer缓冲区中不存在对应的offset，那么会跟上面的初次复制一样，进行全量重同步。
如果Replication ID跟当前的Replication ID一致并且当前buffer缓冲区中存在对应的offset，那么会进行部分重同步。（部分重同步是Redis 2.8之后的版本支持的，主要基于性能考虑，为了断线期间的小部分数据修改进行全量重同步效率比较低）
全量重同步

主节点会执行BGSAVE命令，fork出一个子进程，在后台生成一个RDB持久化文件，完成后，发送给从服务器，从节点接受并载入RDB文件，使得从节点的数据库状态更新至主节点执行BGSAVE命令时的状态。并且在生成RDB文件期间，主节点也会使用一个缓冲区来记录这个期间执行的所有写命令，将这些命令发送给从节点，从节点执行命令将自己数据库状态更新至与主节点完全一致。

部分重同步

因为此时从节点只是落后主节点一小段时间的数据修改，并且偏移量在复制缓冲区buffer中可以找到，所以主节点把从节点落后的这部分数据修改命令发送给从节点，完成同步。

命令传播

在执行全量重同步或者部分重同步以后，主从节点的数据库状态达到一致后，会进入到命令传播阶段。主节点执行修改命令后，会将修改命令添加到内存中的buffer缓冲区（是一个定长的环形数组，满了时就会覆盖前面的数据），然后异步地将buffer缓冲区的命令发送给从节点。

# Redis中哨兵是什么？

Redis中的哨兵服务器是一个运行在哨兵模式下的Redis服务器，核心功能是监测主节点和从节点的运行情况，在主节点出现故障后， 完成自动故障转移，让某个从节点升级为主节点。

# Redis哨兵系统是怎么实现自动故障转移的？

1.认定主节点主观下线

    因为每隔2s，哨兵节点会给主节点发送PING命令，如果在一定时间间隔内，都没有收到回复，那么哨兵节点就认为主节点主观下线。
    
2.认定主节点客观下线

    哨兵节点认定主节点主观下线后，会向其他哨兵节点发送sentinel is-master-down-by-addr命令，获取其他哨兵节点对该主节点的状态，当认定主节点下线的哨兵数量达到一定数值时，就认定主节点客观下线。

3.进行领导者哨兵选举

    认定主节点客观下线后,各个哨兵之间相互通信，选举出一个领导者哨兵，由它来对主节点进行故障转移操作。
    选举使用的是Raft算法

4.领导者哨兵进行故障转移
    
    领导者哨兵节点首先会从从节点中选出一个节点作为新的主节点
    
# 为什么不用红黑树作为zset底层实现？

缺点：

比红黑树占用更多的内存，每个节点的大小取决于该节点的层数
空间局部性较差导致缓存命中率低，感觉上会比红黑树更慢

优点：

实现比红黑树简单    
比红黑树更容易扩展，作者之后实现zrank指令时没怎么改动代码。
红黑树插入删除时为了平衡高度需要旋转附近节点，高并发时需要锁。skiplist不需要考虑。
一般用zset的操作都是执行zrange之类的操作，取出一片连续的节点。这些操作的缓存命中率不会比红黑树低。

