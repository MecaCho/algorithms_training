
# websocket

## Ajax轮训

## Websockets

2011。12 RFC6455

• 双向通讯的优劣?
• 如何管理会话?
• 如何维持长连接?
• 兼容 HTTP 协议 • 端口复用
• 支持扩展
• 如 permessage-deflate 扩展

过滤：
ws
is running

管理会话？
如何维持长链接
兼容HTTP：协议升级

### websocket的约束

实时性与可伸缩：
网络效率与无状态：牺牲了简单性与可见性

### 长连接心跳保持

长连接的心跳保持
• HTTP 长连接只能基于简单的超时(常见为 65 秒)
 • WebSocket 连接基于 ping/pong 心跳机制维持
 
### 兼容 HTTP 协议
• 默认使用 80 或者 443 端口 • 协议升级
• 代理服务器可以简单支持

### 设计哲学:在 Web 约束下暴露 TCP 给上层    

• 元数据去哪了?
• 对比:HTTP 协议头部会存放元数据
• 由 WebSocket 上传输的应用层存放元数据
• 基于帧:不是基于流(HTTP、TCP)
• 每一帧要么承载字符数据，要么承载二进制数据
• 基于浏览器的同源策略模型(非浏览器无效) • 可以使用 Access-Control-Allow-Origin 等头部
• 基于 URI、子协议支持同主机同端口上的多个服务

### 消息与数据帧
    
- Message 消息     
• 1 条消息由 1 个或者多个帧组成，这些数据帧属于同一类型 • 代理服务器可能合并、拆分消息的数据帧

Frame 数据帧     
• 持续帧    
• 文本帧、二进制帧    

### 发送消息    

• 确保 WebSocket 会话处于 OPEN 状态
• 以帧来承载消息，一条消息可以拆分多个数据帧
• 客户端发送的帧必须基于掩码编码
• 一旦发送或者接收到关闭帧，连接处于 CLOSING 状态
• 一旦发送了关闭帧，且接收到关闭帧，连接处于 CLOSED 状态 • TCP 连接关闭后，WebSocket 连接才完全被关闭

### frame-masking-key 掩码        
• 客户端消息:MASK 为 1(包括控制帧)，传递 32 位无法预测的、随机的 Masking-key • 服务器端消息:MASK 为 0

掩码如何防止缓存污染攻击?
• 目的:防止恶意页面上的代码，可以经由浏览器构造出合法的 GET 请求，使得代理服务 器可以识别出请求并缓存响应
• 强制浏览器执行以下方法:
• 生成随机的 32 位 frame-masking-key，不能让 JS 代码猜出(否则可以反向构造)
• 对传输的包体按照 frame-masking-key 执行可对称解密的 XOR 异或操作，使代理服务器不识 别
• 消息编码算法:
• j = i MOD 4
• transformed-octet-i = original-octet-i XOR masking-key-octet-j

### 心跳帧    

• 心跳帧可以插在数据帧中传输 
ping帧    
• opcode=9
• 可以含有数据 
pong帧    
• opcode=A
• 必须与 ping 帧数据相同

### 如何关闭会话？

控制帧中的关闭帧:在 TCP 连接之上的双向关闭     

• 发送关闭帧后，不能再发送任何数据
• 接收到关闭帧后，不再接收任何到达的数据    

关闭帧格式    
• opcode=8
• 可以含有数据，但仅用于解释关

闭会话的原因    
• 前 2 字节为无符号整型
• 遵循 mask 掩码规则

TCP 连接意外中断

###  关闭帧的错误码    

错误码
含义
1000
正常关闭
1001
表示浏览器页面跳转或者服务器将要关机
1002
发现协议错误
1003
接收到不能处理的数据帧(例如某端不能处理二进制消息)
1004
预留
1005
预留(不能用在关闭帧里)，期望但没有接收到错误码
1006
预留(不能用在关闭帧里)，期望给出非正常关闭的错误码
1007
消息格式不符合 opcode(例如文本帧里消息没有用 UTF8 编码)
1008
接收到的消息不遵守某些策略(比 1003、1009 更一般的错误)
1009
消息超出能处理的最大长度
1010
客户端明确需要使用扩展，但服务器没有给出扩展的协商信息
1011
服务器遇到未知条件不能完成请求
1015
预留(不能用在关闭帧里)，表示 TLS 握手失败

# refs

www.websocket.org




