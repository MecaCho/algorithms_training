

# 系统基础

1.Linux系统的启动过程：从硬件上电到init程序加载完毕截止

BIOS自检－>MBR(GRUB)－>KERNEL－>KERNEL自解压－>内核初始化－>内核启动
POST加电自检 -->BIOS(Boot Sequence)-->加载对应引导上的MBR(bootloader)-->主引导设置加载其 BootLoader-->Kernel初始化-->initrd—>/etc/init进程加载/etc/inittab

2.系统中断的机制和使用方法
中断信号由外部设备发起，准确来说是由外部设备的控制器发起；
每个外部设备连接一条中断线，当设备需要中断CPU时，通过这些中断线，发送中断请求。

3.进程、线程、协程的区别，列举系统实现IPC的机制和方法（2-3种至少）
进程是分配资源的基本单位，也是我们说的隔离。
线程作为独立运行和独立调度的基本单位，线程的作用就在于充分使用硬件CPU，也就是我们说的并行，
协程与线程主要区别是它将不再被内核调度，而是交给了程序自己而线程是将自己交给内核调度，所以也不难理解golang中调度器的存在。
系统实现IPC的机制：
	1、共享内存
	2、管道	
	3、信号量
	4、Socket


4.说明竞态条件（race condition）和常见的引发死锁的代码（原因）
两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。

产生死锁的原因主要是： 
（1） 因为系统资源不足。 
（2） 进程运行推进的顺序不合适。 
（3） 资源分配不当等。 
如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则 
就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。 
产生死锁的四个必要条件： 
（1） 互斥条件：一个资源每次只能被一个进程使用。 
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 
这四个条件是 死锁的必要条件 ，只要系统发生死锁，这些条件必然成立，而只要上述条件之 
一不满足，就不会发生死锁。 
死锁的解除与预防： 
理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 
解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 
定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态 
的情况下占用资源。因此，对资源的分配要给予合理的规划。

5.说明系统启动过程中BootLoader与Kernel在内存管理中的区别

6.简要说明Linux内核如何管理内存、虚拟内存
Linux操作系统采用虚拟内存管理技术，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址，无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存），而且更重要的是，用户程序可使用比实际物理内存更大的地址空间。
时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。
虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：
请求分页存储管理。
请求分段存储管理。
请求段页式存储管理。

不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：
一定容量的内存和外存。
页表机制（或段表机制），作为主要的数据结构。
中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。
地址变换机构，逻辑地址到物理地址的变换。

7.简述C++11中智能指针内存管理与Golang GC的区别
智能指针的行为类似普通指针，一个重要区别是他负责自动释放所指向对象的内存。智能指针可以提供对动态分配的内存安全而又方便的管理。
种方法是采用最广泛的做法，但是对程序员有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄露。
golang GC 是语言层面的自动内存管理 – 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由运行时（runtime）来自动进行管理。

8.解释Linux Ext3文件系统中inode的用途，或简单介绍你熟悉的一个文件系统的组织结构
文件数据：储存在”块”（block）中

文件的元信息：比如文件的创建者、文件的创建日期、文件的大小等等。

这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。

每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。

inode包含文件的元信息，具体来说有以下内容：

　　* 文件的字节数

　　* 文件拥有者的User ID

　　* 文件的Group ID

　　* 文件的读、写、执行权限

　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。

　　* 链接数，即有多少文件名指向这个inode

　　* 文件数据block的位置

9.解释Linux系统中的挂载点和分区
Windows中，盘符既用于表示硬件(硬盘上的分区)，又用于表示系统中的路径。而Linux中，硬件就是硬件，路径就是路径
Linux 中的每一个分区都是构成支持一组文件和目录所必需的贮存区的一部分。它是通过挂载(mounting)来实现的，挂载是将分区关联到某一目录的过程

10.列举C++ STL中使用红黑树的对象，列举平衡数的种类、由来及用途

11.简述可以使用动态规划算法的3个必要条件
适用动态规划的问题必须满足最优化原理、无后效性和重叠性。
1.最优化原理（最优子结构性质） 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。

2.无后效性  将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。

3.子问题的重叠性  动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。

12.简述自动状态机与词法分析的关系
13.列举C／C++中未定义行为（Undefined Behaviour，至少2个），并解释原因
C语言没规定，由编译器和机器自由发挥
解引用 nullptr 指针；
解引用一个未初始化的指针；
解引用 new 操作失败返回的指针；
指针访问越界（解引用一个超出数组边界的指针）；
解引用一个指向已销毁对象的指针；
bool的默认值
++I++
有符号整数溢出（文章开头的例子）；
整数做左移操作时，移动的位数为负数；
整数做移位操作时，移动的位数超出整型占的位数。（int64_t i = 1; i <<= 72）；
尝试修改字符串字面值或者常量的内容；
对自动初始化且没有赋初值的变量进行操作；（int i; i++; cout << i;）
在有返回值的函数结束时不返回内容；

14.说明浏览器输入一个网址开始，到网页正确显示所经历的所有可能的过程
1 输入网址
2 域名解析
3 tcp链接->三次握手
4 发送http请求
5 服务器处理请求，并将结果返回
6 浏览器根据返回结果进行处理或页面渲染

15.解释TCP／IP如何保证服务质量（Qos，如滑动窗口、拥塞控制）
1.TCP/IP使用超时重传机制，保证当丢包时能重传该数据包。那如何保证数据包一定到呢，这就引入了确认机制，通过确认保证接收方已经接收到该数据包，并且告诉发送方我想接收的下一个数据包的序号。即为超时重传+确认。

2.应用数据被分为TCP认为合适大小的数据块（MSS段），进行段传输。即为合理分段传输。

3.由于IP是不可靠传递，所以可能数据段失序，此时通过头部的序号进行重排。即为重新排序。

4.TCP头部中有校验和位，通过端到端网际和校验，进行差错校验。即为差错校验。

5.TCP使用滑动窗口实现流量控制。

6.TCP使用拥塞窗口实现拥塞控制。

16.解释容器技术和虚拟化技术的区别，优势和劣势

区别：
	A：
	容器为应用程序提供了隔离的运行空间：
	每个容器内都包含一个独享的完整用户环境空间，并且一个容器内的变动不会影响其他容器的运行环境。
	为了能达到这种效果，容器技术使用了一系列的系统级别的机制诸如：
		1.利用Linux namespaces来进行空间隔离，
		2.通过文件系统的挂载点来决定容器可以访问哪些文件，
		3.通过cgroups来确定每个容器可以利用多少资源。
	此外容器之间共享同一个系统内核，这样当同一个库被多个容器使用时，内存的使用效率会得到提升。 
	B：
	对于系统虚拟化技术来说，虚拟层为用户提供了一个完整的虚拟机：包括内核在内的一个完整的系统镜像。
	CPU虚拟化技术可以为每个用户提供一个独享且和其他用户隔离的系统环境，
	虚拟层可以为每个用户分配虚拟化后的CPU、内存和IO设备资源。 



容器相对虚拟化的优势：                   	
    1.占用磁盘空间小，甚至只有几十KB，虚拟机可达GB；
	2.启动速度快，几秒钟，虚拟机要几分钟
	3.运行形态：docker与宿主机共享内核，虚拟机运行于Hypervisior
	4.并发：docker成百上千，虚拟机最多几十个
	5.性能：docker接近宿主机本地进程，虚拟机不行
	6.docker资源利用率高
	7.docker安全隔离，虚拟机完全隔离；
	
	https://m.youtube.com/watch?v=90kZRyPcRZw#fauxfullscreen

没有内核所以rootfs会比较小，请问一般安装的linux系统内核文件在哪里存放呢？，
作者回复: 首先，docker镜像比较小不只是因为没有内核，内核本身其实不大。
大小的差异主要因为我们平常看见的虚拟机镜像实际上是整个磁盘的快照。
其次，一般情况下，内核放下安装盘里，解压到磁盘上，加载到内存中。
有兴趣可以读这里：https://blog.csdn.net/gatieme/article/details/50914250

17.简单阐述深度神经网络的反向传播算法，有能力应附带推导公式
18.任选一种语言，说明其进行性能分析的方法
python：
	timing
	cProfile
Golang：
	pporf
	Benchmark

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None


def quick_sort(arr):
    if arr:
        left_arr = [node for node in arr if node.val < arr[0].val]
        mid_arr = [node for node in arr if node.val == arr[0].val]
        right_arr = [node for node in arr if node.val > arr[0].val]
        return quick_sort(left_arr) + mid_arr + quick_sort(right_arr)
    return []


class Solution(object):
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        all_nodes = []
        for node_list in lists:
            node = node_list
            while node is not None:
                all_nodes.append(node)
                node = node.next
        all_nodes = quick_sort(all_nodes)
        for i in xrange(len(all_nodes) - 1):
            all_nodes[i].next = all_nodes[i + 1]
        if all_nodes:
            return all_nodes[0]
        else:
            return None
```
