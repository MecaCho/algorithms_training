
# 什么时候该使用MQ？

MQ是一个互联网架构中常见的解耦利器。

什么时候不使用MQ？
上游实时关注执行结果，通常采用RPC。
 
什么时候使用MQ？
（1）数据驱动的任务依赖；    
（2）上游不关心多下游执行结果；    
（3）异步返回执行时间长；    

## 使用场景

1。异步

2。

# RabbitMQ

erlang语言开发， 基于AMQP（Advanced Message Queue Protocol）

## 工作原理

Producer----connection----Broker（Exchange、Queue）----connection----Consumer
              channel
              
'exchange'----消息转发

## 工作模式----发布订阅模式    

## 工作模式----路由工作模式 direct

## 工作模式----通配符工作模式 topic

## 工作模式----header-rpc工作模式    


# Kafka、RocketMQ、RabbitMQ都不能保证消息不重不丢（Exactly Once）

消息可靠性的服务水平：

- At most once：至多一次，允许丢消息
- At least once：至少一次，不允许丢消息，可以重复
- Exactly once：恰好一次，不允许丢也不重复


# questions

## 1。为什么用？

解耦：    
异步：    
削峰：    

## 2。各种产品比较？

|  产品    |开发语言|单机吞吐量|时效性|高可用        |功能特性|
|----------|------|--------|------|-----------|-------｜
|`RabbitMQ`|erlang|万级     |us    |高、分布式       |         ｜
|`Kafka`   |scala  |10万级  |ms    |非常高、分布式    |         ｜
|`RocketMQ`|java  |10万级   |ms    | 非常高、分布式    |        ｜
|`ActiveMQ`|java  |万级     |ms    |高、主从架构      |        ｜


## 3。消息队列的优点和缺点？

可用性降低----集群    
系统变复杂----
数据一致性问题----最终一致性        

## 4。如何保证消息队列的高可用？

### rabbitMQ高可用

### RocketMQ高可用----双主双从



## 5。如何保证消息不丢失？

### 分析原因

1。生产者    
2。MQ    
3。消费者    

### 解决

1。confirm
2。消息持久化
3。ack确认


## 6。保证消息不被重复消费？

### 原因

根本原因是网络不可达，不可避免
1。发送时消息重复    
2。消费时消费重复

### 解决

保证消息幂等

1。唯一id
2。消费者根据id查询是否消费
3。消费完毕写入redis/db
4。如果已经消费就丢弃


## 7。如何保证消息顺序消费？

1。是否理解消息的顺序消费
2。

全局顺序消费、局部顺序消费

### 解决

一个消费者一个队列
MQ使用分段锁来保证单个Queue的有序消费

## 8。大量消息堆积如何处理？

### 原因：

1。消费者出现故障    
2。消费了没有ack    

### 解决

1。恢复消费者
2。写程序转发处理

## 9。消息过期？

### 原因

设置过期时间
过期消息可以转入死信队列

### 解决

1。启用专门消费者消费过期消息，记录日志
2。重新查询过期消息

