

# 使用缓存保护MySQL

MySQL 能承担的并发读写的量是有上限的，当系统的在线用户超过几万到几十万这个量级的时候，
单台 MySQL 就很难应付了。

# 为什么快？

Redis 是一个使用内存保存数据的高性能 KV 数据库，它的高性能主要来自于：
- 简单的数据结构；
- 使用内存存储数据。

缺点：
Redis 仍然是一个不可靠的存储，它在设计上天然就不保证数据的可靠性，所以一般我们都使用 Redis 做缓存，很少使用它作为唯一的数据存储。

# 缓存穿透引起雪崩

如果我们的缓存命中率比较低，就会出现大量“缓存穿透”的情况。
缓存穿透指的是，在读数据的时候，没有命中缓存，请求“穿透”了缓存，直接访问后端数据库的情况。

1.少量的缓存穿透是正常的，我们需要预防的是，短时间内大量的请求无法命中缓存，请求穿透到数据库，导致数据库繁忙，
请求超时。
大量的请求超时还会引发更多的重试请求，更多的重试请求让数据库更加繁忙，这样恶性循环导致系统雪崩。

2.当系统初始化的时候，比如说系统升级重启或者是缓存刚上线，这个时候缓存是空的，如果大量的请求直接打过来，很容易引发大量缓存穿透导致雪崩。

3.还有一种常见的缓存穿透引起雪崩的情况是，当发生缓存穿透时，如果从数据库中读取数据的时间比较长，也容易引起数据库雪崩。

4.我们缓存的数据是一个复杂的数据库联查结果，如果在数据库执行这个查询需要 10 秒钟，
    那当缓存中这条数据过期之后，最少 10 秒内，缓存中都不会有数据。
    如果这 10 秒内有大量的请求都需要读取这个缓存数据，这些请求都会穿透缓存，打到数据库上，
    这样很容易导致数据库繁忙，当请求量比较大的时候就会引起雪崩。
    
在系统初始化阶段，需要使用灰度发布或者其他方式来对缓存进行预热。

对于Cache aside和read/write through而带来的数据不一致问题，工作中是这样解决：
a写线程，b读线程：
b线程：读缓存->未命中->上写锁>从db读数据到缓存->释放锁；
a线程：上写锁->写db->删除缓存/改缓存->释放锁；
这样来保证a，b线程并发读写缓存带来的脏数据问题；

# 缓存穿透：超大规模系统

并发请求的数量这个基数太大了，即使有很小比率的请求穿透缓存，打到数据库上请求的绝对数量仍然不小。加上大促期间的流量峰值，还是存在缓存穿透引发雪崩的风险。

对于像订单服务这类核心的业务，一个可行的方法是，我们启动一个更新订单缓存的服务，接收订单变更的 MQ 消息，然后更新 Redis 中缓存的订单数据

## 使用 Binlog 实时更新 Redis 缓存

有很多开源的项目就提供了订阅和解析 MySQL Binlog 的功能，
下面我们以比较常用的开源项目Canal为例，来演示一下如何实时接收 Binlog 更新 Redis 缓存。
Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，
MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。下图是 Canal 的工作原理：


